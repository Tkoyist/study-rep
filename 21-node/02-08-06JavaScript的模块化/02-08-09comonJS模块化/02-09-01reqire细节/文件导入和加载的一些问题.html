<!-- 
  - cmj 中文件的加载是同步的，即如果文件没有成功加载，那么后续代码是会被阻塞的

  - cmj 中加载一个模块之前会先执行那个模块内部的代码
    我们知道moudule本质上是一个伪全局对象，它所保存的就是关于模块的一些信息，每一个模块都有自己的module 对象，内部保存了例如是否被其他模块加载，引用了哪些模块等数据

  - 我们知道模块之间的各种引用关系大量的出现，会产生一个巨大的相互引用的引用关系网络
    这也就产生了两个问题
      * 每次引用都要执行代码，那么多次引用是否会多次加载浪费性能
        只会被加载（运行一次），前面说道，模块的module 对象中保存了文件模块化的一些数据，其中就包括 loaded 属性，专门指明了当前文件是否被加载过
        当某个模块需要使用该模块的时候，会先去访问该属性，如果该属性的值为true 则表示该文件已经被加载过，可以直接使用其module.exports 对象,即该模块的导出数据对象

  - 如果产生了模块之间的循坏导入怎么办，加载顺序又是如何
    * 前面说道，我们加载一个文件的时候会去通过module.loaded 得知该文件是否被加载过，当出现循环引用的时候，循环到头总会访问到某个已经被加载的文件，访问到该文件之后，node 会获取到该文件已经被加载，那么就不会再加载该文件，这样就断掉了循环
    * 而加载顺序，对于这些模块来说，加载顺序是根据深度优先算法来进行的，因为我们在一个模块当中加载其他的模块，也就是使用require 导入其他模块的时候，其实模块的导入之间也是存在有先后顺序的，也符合深度优先算法的要求
    
 -->