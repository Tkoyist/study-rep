<!-- 
  ** 我们在使用cmj导入一个模块的时候，会先运行被导入模块当中的代码

  并且这种运行时同步的，即我们在一个模块当中使用require函数导入一个文件的时候，require函数会先去执行这个模块的代码，然后进行当前模块的后续操作

  一个外部模块的加载通常只会进行一次，如果在一个模块中多次使用了某个外部模块，这个外部模块也是只会执行一次的，后面的使用则是使用了之前的缓存


  上面提到了，module 对象当中是存在一个loaded 对象的，当我们在某个地方加载了该外部模块，那么该外部模块的module.loaded 属性就会变成true，表示已经被加载完成
  之後再有模块使用该模块时，先访问其module.loaded属性，发现为ture，表示该模块内部代码已经执行过，则直接使用其module.exports 当中的代码
  *** 为什么要这样设计？
      首先我们导入一个模块的目的就是使用该模块的module.exports 当中的数据（变量，函数与对象），但是这些数据的产生，是要在模块内部代码执行完毕之后
      也就是说，需要模块内部的代码执行完成之后才能产生module.exports 以及其内部的我们需要的数据，因此我们肯定是需要执行一次代码的
      那为什么不每次使用单独加载（为什么不用单独加载）？因为我们前面讲过，模块化的特征就是模块之间不相互干扰，这也就意味着，不论我们在哪里使用模块，使用的它导出的数据，即module.exports 内部的数据都是相同的
      不会因为使用环境的不同，而产生不同的导出数据，既然总是相同的导出数据，
      当访问到一个模块的module.loaded为true，当前模块已经加载过后，我们根本就没有必要多次单独加载，或者说完全可以直接使用module.exports当中的数据，根本没有必要再加载运行一次

  *** 导入一个模块的流程
    - 发现require 函数调用，依据require 函数的访问原则寻找到该模块
    - 访问其module.loaded 属性，判断其是否运行过
      - 运行过 ：module.exports 当中已经有我们需要的数据了，直接使用module.exports 当中的数据即可
      - 没有运行过 ：module.exports当中还没有我们需要的数据，运行该代码，使得module.exports 当中的值变成我们想要的值，然后使用该值
 -->