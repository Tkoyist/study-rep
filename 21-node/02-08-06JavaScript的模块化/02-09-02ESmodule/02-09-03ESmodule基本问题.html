<!-- 
  - 先来说说它与cmj 的不同之处
    * cmj 使用的是对象存储数据，方法访问数据，而esmodule 使用了两个关键字 export 和 import ，注意这是两个关键字，是专门为es模块化创造的关键字

  - 常见的导出
    * 常规使用，直接导出某个数据（变量，方法等）
    * 使用export 关键字和 {} 结合使用的特殊语法，将需要导出的数据放在{}内部，直接导出内部的所有数据
      · 注意这并不代表着导出了一个对象，这也是esmodule 的特殊语法， export {  }  就是一个特殊的语法，会将{}内部的数据全部导出，也并不是作为一个对象导出了，就是直接导出了，一个特殊语法而已
        所以内部也不能使用键值对，只能将变量直接放入
    * 在方式二的基础上，我们可以为导出的数据添加别名导出
        export {
          name as fname,
          age as fage
        }
        这样我们就可以在导入模块的模块中通过 fname 和 fage 访问到数据了
    

    - 常见的导入
      * 普通导入
       import {数据名} from '模块地址'
       这样可以直接导入其他文件中导出的指定的数据
       **** 但是也要注意，这不是导入了一个对象然后进行了解构，这就是一个特殊语法，直接导入了这些数据

      * 别名导入
        我们也可以为导入的数据添加别名
        import {数据名 as 别名} from '模块地址'
        这样我们就可以在当前模块当中使用别名直接访问数据

      * 全部导入
        import * from '模块地址'
        会直接导入某个模块中导出的全部数据

      *** 注意：原本的es模块化的导入是需要将导入模块的后缀名加上的，但是我们开发中可以忽略（vue 和 react 开发中都是如此）
                这原本是不符合es模块化的规则的，只是底层的webpack 帮我们实现了类似于node 当中的功能，添加上各种后缀再帮我们寻找

    - 直接导入导出
      export {从其他模块导入并准备从当前模块导出的数据} from '模块地址'
      这样就可以直接将来自其他模块的数据直接通过当前模块导出
      很多第三方库都要使用这个语法将库中的所有接口统一放到index.js 当中一次性导出

    - import 函数，我们不能将模块的导入放到逻辑判断语句当中
      js 代码的执行是交由js 引擎进行的，而js 引擎在执行js代码之前会先对代码进行分词解析，而在这个阶段，js引擎读取到了import 语句，就会直接去获取依赖，导入模块
      但是现在只是解析阶段，如果存在逻辑代码，我们都不知道是否需要对逻辑代码内部的import 语句进行执行，也就是说，根本就不知道是否需要导入模块，但是在代码执行之前就必须导入
      简而言之
      我们在解析代码时就要导入模块，但是由于逻辑代码的存在，我们不能确定是否要导入模块，必须要解析完成，代码执行时才能知道是否需要导入模块，但是在逻辑代码执行完成之前又必须要解析代码，导入模块
      这也就变成了死循环
      为什么require 不会出现这个问题
      因为require 本质上就是一个函数，它是在es5 的基础上，使用es5 代码实现的模块化导入，根本就是在代码执行阶段才进行的导入，当然不会出现任何问题

      我们当然要解决这个问题，所以出现了import() 函数，它虽然是esmodule 的导入方式，但是它的本质依然是一个函数，这也就意味着它的导入是在代码执行阶段进行的，不会出现上面说到的死循环问题
      import 函数将import 关键字无法在逻辑代码中使用的问题以import 函数化的方式解决了，同时也解决了另外一些问题
      * import() 函数为什么是异步的？
        这先要说道为什么import 关键字是同步的，我们前面说道，在js代码解析的阶段 就是将js代码解析成为中间码的阶段（并未执行）js引擎就已经将模块内部的导入（即import）理清楚并导入了
        这样在执行当前模块的js 代码的时候，直接去对应的位置取数据就可以了，这样是可以提高效率的，并且因为不是在程序运行阶段进行的工作，所以根本无需使用异步操作，直接使用同步代码即可
        但是当出现动态加载的时候（以加载动态模块为例）当我们需要加载的模块是不确定的的情况下，我们无法在解析阶段就加载数据（根本不知道这个时候加载什么模块的数据，怎么加载）所以使用了函数的方式进行加载
        但是这样又引出了另外一个问题，import 的加载都是同步的，但是如果在用户运行时，我们同步的加载某个模块，不仅耗时，而且如果加载出错，那么整体页面都会出错
        这两个问题都是import 函数化产生的
        这样显然是不行的
        所以在此基础上提出了解决方案，即将import 函数定义为异步任务
        所以在import 函数内部使用了异步加载的方式加载模块数据，返回一个promise 作为函数返回值
        - js 代码可以直接正常运行，只需要等待异步的模块加载完成就可以了，不会影响用户的使用
        - 如果加载出错，那么直接使用我们在catch 方法中预定义的解决方案即可，不会导致整个网页出错（话说回来，动态加载确实错误率要更高，也应当有错误解决方案）
        函数化 解决死循环问题，但是产生了新的问题，异步化则是解决了函数化产生的问题

        *******上面说的有误
        esmodule 的模块数据的获取都是异步的，这样也是为了提高解析效率吧可能，这我暂时想不出什么原因，但是也不是很重要，总之就是其他模块的数据的获取是交由其他线程完成的
        当解析进行的时候，读取到import 语句，就会直接异步的加载该模块的数据，然后主线程继续进行
        因为在解析阶段就去直接同步加载模块的话，会整个拖累代码的执行，这显然是不行的

 -->