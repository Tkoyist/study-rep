###### js引擎是什么

​	js作为一门高级语言，是无法被cpu直接执行的，cpu只能执行对应的指令集，也就是机器语言，因此，我们想要在计算机上执行js代码，就必须将js转化为对应的及其语言，而js引擎就是用来完成这个工作的，它会将js代码转化为机器语言

###### js代码执行过程

JavaScript代码

**词法分析**

token

**语法分析（解析或预解析）**

AST（虚拟语法树）：本质上是一个数组，数组包含了大量对象，每一个对象都对应了一个token，内部保存了

token的大量信息

+ 预解析：在作用域当中定义的函数v8引擎并不会将其直接解析为ast，因为有些函数可能根本不会被执行，即使会被执行，我们也没有必要非要在一开始就将其内部代码解析，完全可以等到函数被调用的时候再解析为ast树执行，这是一个优化策略，用于提高js代码的执行效率（但是在函数执行的时候依然会被解析）

**解释器生成字节码** 

字节码：介于机器码与js代码之间的代码

**解释器逐行对字节码进行解释与执行**

机器码：可以直接被cpu执行的代码

+ 为什么要逐行转化，而不直接全部转化，js代码全部转化为机器码会占用大量的内存
+ 解释执行过程的优化策略：v8引擎会将一些出现频率高的代码直接编译机器码进行保存，这样需要使用热点代码的地方可以直接使用机器码，可以提高效率。
+ 反解释：由于js是弱类型语言，同样的代码在不同的情况之下可能会需要不同的逻辑，需要不同的处理，如果热点代码遇到这种情况，就不得不先将其反解释为字节码，再转化为机器码执行

###### 代码正式执行之前，有哪些预备工作

+ 首先会开辟一个执行上下文栈（函数执行栈）（ECS），用于管理代码执行顺序，顾名思义，它本质是一个栈结构，内部会依次压入和推出执行上下文

  **执行上下文**：对js代码执行环境的抽象概念，js代码的执行都是在执行上下文当中的，每一个执行上下文都关联着一个VO（变量对象）（执行上下文对象）（当前作用域对象），和其父级作用域指针

  ​	**注意**：区分开执行上下文与执行上下文对象(VO VE)，执行上下文包含了执行上下文对象（包含了变量环境）

  ​	**注意**：在最新的规范当中变量环境VO被命名为了VE，但是本质上是一个东西，变量环境，（函数&全局）执行上下文对象，作用域对象，都是指的同一个东西

  执行上下文被分为两类：

  + GEC：全局执行上下文，全局作用域的执行上下文，其VO指向GO，父级作用域指向空
  + FEC：函数执行上下文，函数作用域的执行上下文，其VO就是指向当前的函数作用域对象AO（**注意：函数的参数也会被保存到函数执行上下文对象当中**）

+ 在全局执行js代码的时候，会向执行上下文栈当中推入全局执行上下文，然后解析代码，准备好VO(GO)（**在这个过程中，会解析代码，将变量声明的代码提前执行，也就是我们所说的变量提升**），再执行代码

  **关于变量提升**：上面已经讲到了变量提升的基本原理，但是声明代码的执行也是有区分的，对变量的声明就是之前声明，赋值为undefined，**而对函数的提前声明，会直接为其开辟一块内存，内存中保存了函数代码（注意只是保存，没有解析），而我们引入的函数，本质上是指向该内存的地址**

+ 在全局执行代码的过程中，如果需要执行某个函数，那么则会在执行上下文栈当中推入一个函数执行上下文FEC，准备好VO（AO），再执行代码，函数执行完毕之后，会将其对应的执行上下文从执行上下文栈中出栈，然后执行栈中的下一执行上下文当中代码，

+ 全局代码执行完毕之后，栈底的全局执行上下文出栈，清空执行栈，代码执行结束。