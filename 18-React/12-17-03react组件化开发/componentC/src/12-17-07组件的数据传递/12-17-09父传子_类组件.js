import React, { Component } from 'react'

// react 中父子组件的通信都是通过 props 属性，这和vue 是不同的
// 创建子组件用于通信
class Main extends Component {
  // constructor(props){
  //   super()
  //   this.props=props
  // }
  // 使用这种方法就是将拿到的prop对象直接在当前的组件类中重新定义了，将其定义为了当前组件的数据
  // 简单但麻烦,还浪费空间
  // 易于理解,但是我们要在这里明白,子组件是可以在构造函数中以参数的形式获取到来自于父组件通过属性传入的数据的

  // 应该这么理解,这个组件类本质是一个组件构造器,我们在父组件中真正使用子组件的时候是通过这个组件构造器构造了一个组件
  // 当然同时构造了一个专门的类,与构造出来的组件相绑定(这样才能保证组件的复用性,使复用的组件之间数据独立)
  // 而我们在使用组件构造器,或者说组件类构造一个组件的时候,就能获取到使用者(使用该组件的父组件)传递的数据,传递的方式就是标签的属性
  // 而组件构造器接受到属性之后,就会将该数据传入组件类的构造函数,以构造当前组件专有的绑定的数据对象,而解析属性传入构造函数的工作是由react实现的
  // 在react 组件生命周期中也确实要在render 函数运行之前先执行constructer 用于初始化数据,一切都合理了,声明周期和这里的知识都串联起来了



  // 12-18更新： react 在渲染过程中，在构造函数执行完毕之后，在render 函数执行之前，会自动取得props 中的数据并将props挂载到当前的组件对象上
  // 所以即使我们故意不挂载数据,也不允许构造函数自动调用父类构造函数挂载数据,react 依然会在render() 函数执行之前读取来自父元素的数据并挂载到组件对象上



  // 新方法,直接将数据传给super 我们一样能直接使用数据
  // constructor(props){
  //     super(props)
  //   }
  // 我们又知道，在继承的本质当中，我们调用父类构造方法是使用call 将该构造方法的this 指向了当前正在创建的子类对象
  // 所以我们看似使用了父类的构造方法,但实际上是为子类对象创建了数据

  // 我们之前有个误区，误以为子组件类的父类就是父组件类，这太愚蠢了，所有组件类的父类都是React.Component 类，即react组件类
  // 在这个类中,实现了功能,接受来自于jsx 中传给组件的属性和属性值,然后将接受到的属性处理并作为参数props 传入组件类的构造函数


  // 前面我们都是说过了继承的实现了,我们当然应该知道子类默认就会将构造函数接受到的参数传给父类构造方法,然后再自动调用父类的构造方法(并且通过call 函数将父类构造方法的this 指向当前创建的对象)
  // 所以上面的代码完全可以直接省略


  render() {
      return (
          <div>
              这是子组件
              <div>
                {this.props.msg}
              </div>
          </div>
      )
  }
}


export default class App extends Component {
  constructor() {
    super()
    this.state={
      msg:'这是来自于父组件的数据a'
    }
  }
  render() {
    return (
      // 先实现简单的数据传递，我们在父组件中使用子组件标签的时候可以为其定义一些属性，我们可以将需要传递给子组件的数据直接放到标签的属性当中传入
      <div>
                这是父组件
                <Main msg={this.state.msg}/>
            </div>
        )
      }
    }
    