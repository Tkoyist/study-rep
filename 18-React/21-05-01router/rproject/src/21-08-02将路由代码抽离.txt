我们在vue 中会将路由的代码单独抽离出来进行处理，同一进行管理
在react 中我们也可以将路由代码单出抽离出来，但是单独抽离的路由代码是依赖于另外一个路由包
- 安装包
yarn add react-router-config@5.1.1

- 导入
我们主要使用包中的renderRoutes 方法，只导入该方法即可

- 使用
renderRoutes 会直接返回jsx 代码，对它的使用，直接在代码中使用 { } 包裹起来即可，他就会在{ } 所在的位置直接生成jsx 代码
该方法接受一个固定格式的routes 数组作为参数，数组中需要以对象的形式存储路由关系表（就像Route组件中那样将url 与组件一一对应）
routes 数组中会以对象的形式存储路由关系
renderRoutes 方法的返回值会成为和vue 中的 router-view 组件一样的占位资源，用于展示路由
同时也和vue 中一样，默认就是排他式的路由匹配
在我们使用Link 修改url 之后，就能在renderRoutes 所占的位置处进行路由的匹配与展示了

抽离路由的嵌套路由
Routes 中的路由对象可以定义一个参数Routes ，没错，与路由总表同名，就表示一个单独的路由映射表
对子路由的使用，我们上面只是创建了一个路由映射表，我们还需要为子路由在指定的位置创建路由占位资源，这里当然我们又要用到renderRoutes 函数了，使用renderRoutes 在子路由界面的特定位置进行占位

经过测试，子路由完全可以是一个单独的routes 文件中的单独的路由，想想也是，每一个renderRoutes 都是独立运作的，不需要什么附加条件

但是我们更加倾向于将某个子路由的routes 直接放在它的路由映射对象中，然后在组件内部通过props 直接访问到当前页面所对应的路由映射对象，再获取到该对象的routes 属性，从而得到子路由的路由映射关系routes

对了，我们将子路由的routes 放在父路由映射对象中作为其属性，本质上只是为了方便获取，确实子路由的routes 可以放在任何位置，都是没有关系的