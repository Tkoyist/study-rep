<!-- 
    - 我们直接通过getter 和 setter 访问修改数据存在一个问题，我们不论对属性进行任何修改，我们访问属性值的时候，都是倔强的去访问getter 返回的值永远是我们设置的初始值
      而我们通过setter 修改的值永远无法生效
      所以我们需要一个全局的变量，当我们获取属性值的时候，getter方法中返回该变量值，而当我们修改属性值的时候，是将newValue 的值赋给该全局变量
      这个全局变量需要很多，如果我们每个属性都一一重新创建变量，势必污染变量命名域，而且该属性必须被封装起来，不能在对象以外的地方被访问到
      所以面对这种变量的保存，显然我们应当使用闭包，在保证其能被getter 和 setter 访问到的前提下，也存在一定的封装保密性，且不会污染变量命名域


      我们将封装好的闭包外部方法称之为 defineReactive()
      var obj = {}
      function defineReactive(data,key,val){
          Object.defineProperty(data,key,{
            get(){
                return val
            }
            set(newValue){
                val = newValue
            }
          })
      }
      这里就完成了一个闭包，将val 封装了起来，咋一看，这里没有返回一个外部接口（我们之前学到的闭包都需要返回一个函数作为外部接口，由外部接口访问到outter 函数中的数据，在外部通过外部接口访问到了封装的数据之后才能真正实现闭包）
      但是我们之前说道，在修改和访问对应数据的时候，就会直接访问到set 和 get 函数，而set 和 get 函数就会访问到 外部函数 中的数据，而浏览器就会保存对应数据，从而形成对闭包的使用
      即get 和 set 就是外部接口，只是因为他们无需像常规闭包一样只能通过返回一个接口函数才能访问数据，而是defineReactive 的getter 和 setter 直接对应了数据的访问和修改，而数据的访问和修改就是该闭包的外部接口

      而闭包的失效（闭包的生命周期结束）是在闭包的接口成为垃圾对象（没有引用指向）的时候，getter 和 setter 函数是一直存在引用的（webpack 还是 vue 提供的暂时不清楚，猜测是webpack提供），即getter 和 setter 至少目前没有办法使其成为垃圾对象，所以val 也会一直存在

      现在我们直接使用defineReactive 函数就能进行对象数据的定义和修改了
 -->