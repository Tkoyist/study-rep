
// 之前一直说js 是单线程语言，无法处理多线程代码，所以提出了很多异步代码处理方案
// 但是一直有一个疑惑，为什么说js 是单线程语言，多线程代码直接执行不就行了，又不会出错
//  这里先说结论：
//  js确实无法处理多线程代码,这并不代表完全处理不了,只是处理会出错

// **举例
// 我们现在写一个异步任务处理函数，用于处理异步任务，使用延时器来模仿
function getData(url){
    setTimeout(() => {
        return url
    }, 1000);
}

// 现在，我们真的能拿到返回的url吗
console.log(getData('123123123')); // 无返回值

// 可以看到是没有返回值的
// 原因：我们在传入参数进入函数之后，直接开启了延时器，将延时器内部代码放入了宏任务队列的队尾包括我们希望的返回代码(return url)
//      放入宏任务队列之后，继续执行同步代码，“ 然后函数就执行完毕了！！！ ”，并没有执行到延时器中的return 那一行，然后当当前宏任务完成之后，执行下一个宏任务的代码，这时候才执行到我们一开始编写的异步任务中的返回代码
//      所以异步代码确实执行了，返回值也确实返回了，只是没有返回到我们希望返回的位置
//      本质原因还是js的单线程性质，导致其不能分出线程来专门跟踪异步函数内部的异步任务执行
//      所以在常规情况下，我们就只能使用不断嵌套的方式处理异步代码：但是这样一是回调层次太多，二是会堵塞主线程代码

// 这就是对js单线程性质无法处理异步代码的理解