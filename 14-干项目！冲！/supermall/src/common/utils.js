// 用于存储一些公用的工具函数

export function debounce(func,delay){
    let timer = null
    return function(...args){
        if(timer) clearTimeout(timer)
        timer = setTimeout(()=>{
            // console.log("进行防抖处理的函数代码执行");
            func.apply(this,args)
        },delay)
    }

// 原理
// 注意函数内部只有一个方法可以执行我们传入的函数
// 那就是等待内部的延时器执行,但是由于这是用于多次刷新的函数
// 所以短时间内就会立即再调用整个函数,而在调用函数之后,会立即将该延时器清除
// 如果在延时器事件到达之前该函数就再次调用的话,那么这个函数不会产生任何效果
// 只能在某一次执行之后,在我们规定的时间之内没有再次调用该函数,内部的函数才能执行
// 原本我们在外部定义的timer 在函数执行完毕之后应该消除，但是注意这是一个闭包
// 我们是将我们需要防抖动的函数传入该函数,该函数会将我们传入的函数进行防抖动操作之后返回
// 我们使用它返回的函数，该函数即是已经进行防抖动处理的函数，我们使用该函数，它就会由于我们上面提到的原理，无法在短时间内多次运行

// - 我们即使不传入delay 函数，不给延时器设置事件，依然会存在一定的防抖动效果，这是因为延时器作为异步执行代码，是会在同步代码执行完毕之后再执行
//   而如果在同步代码执行完毕之前，异步代码还未开始执行的时候，就又调用了该函数，将延时器内部的异步代码在执行之前就将延时器删除，那么本次的请求就会落空，内部代码也将无法执行

// 使用
// 我们使用该方法的时候需要传入我们想要执行但需要防抖动的函数
// 传入之后,获取到debounce 函数的返回值（也是一个函数），就可以直接使用该函数了
// （其实就是闭包的普通使用）

// 注意
// 之前我们说到防抖动是使得一段时间内的请求只有一个生效，但是以该方式的实现，是不能达到这个目的的
// debounce 函数的防抖动是设置一个时间间隔，如果某个请求与其前一个请求间的间隔时间小于该时间间隔，使得该请求无效
// 倘若请求一直连续不断，且都小于该时间间隔，那么经过debounce 函数处理的函数将永远无法执行传入的函数代码
}


// 时间转换函数，将时间戳转换为正常时间输出
export function timestampToTime(timestamp) {
    var date = new Date(timestamp * 1000);//时间戳为10位需*1000，时间戳为13位的话不需乘1000
    var Y = date.getFullYear() + '-';
    var M = (date.getMonth()+1 < 10 ? '0'+(date.getMonth()+1) : date.getMonth()+1) + '-';
    var D = date.getDate() + ' ';
    var h = date.getHours() + ':';
    var m = date.getMinutes() + ':';
    var s = date.getSeconds();
    return Y+M+D+h+m+s;
}
