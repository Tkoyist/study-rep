import {
    init,
    classModule,//类模块
    propsModule,//参数模块
    styleModule,//样式模块
    eventListenersModule,//事件监听模块
    h,
  } from "snabbdom";

// 2 使用h函数创建的虚拟节点无法上树，我们可以通过patch函数上树
// 创建patch函数（看起来是一个thunk函数,通过我们传入的特定模块创建特定的patch函数）
const patch = init([classModule,propsModule,styleModule,eventListenersModule])

const vnode1 = h('ul',{},[
    h('li',{key:'1'},'1'),
    h('li',{key:'2'},'2'),
    h('li',{key:'3'},'3'),
    h('li',{key:'4'},'4'),
])

const container = document.getElementById('container')
const btn = document.getElementById('btn')

patch(container,vnode1)

const vnode2 = h('ul',{},[
    h('li',{key:'5'},'5'),
    h('li',{key:'1'},'1'),
    h('li',{key:'2'},'2'),
    h('li',{key:'3'},'3'),
    h('li',{key:'4'},'4'),
])

btn.onclick = function(){
    // 使用patch 函数更新vnode 将vnode1 更新为 vnode2
    // patch 传入两个虚拟节点作为参数，会使用后面一个节点更新前面一个节点
    patch(vnode1,vnode2)
    // patch 函数并不是将vnode1 修改为vnode2 而是找到vnode2 与vnode1 的不同之处，然后将真实dom 树上需要修改的地方修改掉，并不会改变虚拟节点
    // 所以多次点击之下，由于多次点击之后vnode1 和vnode2 之间仍然是固定的地方不同，所以每次对真实dom 上的修改也都是相同的

    // * 当vnode2 的修改是在所有子节点之前加上一个节点的情况下，我们会发现patch 函数做的事情
    //      是将vnode1 和vnode2 中的子节点逐一对比，对比下来会发现每一个节点都改变了（vnode1 的第1,2,3,4个子节点和vnode2 的底1,2,3,4个子节点无法一一对应相同）
    //      而遍历到最后一个子节点时vnode2 的最后一个子节点是 4 ，于是添加上了4，我们发现，明明只在最前方加上了一个子节点，却导致所有的子节点都发生了改变，这是低效率的
    //  而当我们为子节点添加上key 属性,为其绑定唯一的标识之后,就不会出现这种情况了,key 是该节点的唯一标识,它会告诉diff 算法自己唯一对应更新后的虚拟节点树上的某个节点
    //  而当节点没有key 属性时,diff 算法就会默认的拿它与新虚拟dom上的相同位置的节点进行对比,如果改变了,则做出对应的更新
    //  而在有对应key 的情况下,会直接将key 作为节点更新判断的标识,而不使用默认的方法

    // * 当某个节点的选择器或者可以发生改变之后,它就会被试做新的节点,不会与变化前的节点进行精细化对比
    //      它会被暴力拆解,然后重新建立,而该节点的子节点也会一样的直接暴力拆解重做,而不会进行精细化对比
    // 在实际开发中也很少直接改变dom节点的选择器或者key，所以无需单独进行特判（对所有节点进行这种特判反而影响效率）

    // * 节点只会进行同层比较
    //      如果将相同的一片虚拟节点放到了与之前的不同层的情况下，diff算法是无法识别的，只会直接暴力删除更新，它只会使用新虚拟节点中与旧虚拟节点同层的节点进行比较，而不会使用一层的节点与另外一层的节点进行比较
    //      即便使用了key绑定也不行（说明对key 的遍历寻访只会在同层中进行），当在一层中进行比对时，找不到对应的节点（对应节点已经被移动到了其他层）的情况下，就会直接将其更新，而不会拿着节点去它的字节点寻找（如果要考虑跨层更新，那就需要将改变的节点与原节点中的所有节点进行比对，这样成本太大）
    // 这种情况实际开发也少，所以也不影响diff 的整体效率
}